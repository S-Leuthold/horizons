% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluation-worker_manager.R
\name{manage_worker_pool}
\alias{manage_worker_pool}
\title{Manage Worker Pool for Parallel Model Evaluation}
\usage{
manage_worker_pool(
  n_workers_requested,
  task_type = c("grid_search", "bayesian", "refit"),
  n_tasks = NULL,
  cv_folds = 5,
  verbose = FALSE
)
}
\arguments{
\item{n_workers_requested}{Integer. Number of workers requested by user (1-190)}

\item{task_type}{Character. Type of task: "grid_search", "bayesian", or "refit"}

\item{n_tasks}{Integer. Number of tasks to parallelize (e.g., hyperparameter combinations)}

\item{cv_folds}{Integer. Number of cross-validation folds}

\item{verbose}{Logical. Print diagnostic information (default = FALSE)}
}
\value{
A list containing:
\itemize{
\item \strong{n_workers}: Optimal number of workers to use
\item \strong{parallel_plan}: Future plan object configured for the environment
\item \strong{strategy}: Character description of parallelization strategy
\item \strong{cleanup_fn}: Function to call after parallel operations complete
}
}
\description{
Manages worker allocation, prevents nested parallelization, and optimizes resource
utilization for HPC environments. This function intelligently allocates workers
based on the task type (grid search vs Bayesian optimization) and available resources.

Key features:
\itemize{
\item Dynamic worker calculation based on task requirements
\item Nested parallelization prevention via environment variables
\item Platform-specific optimizations (Linux multicore vs others)
\item Memory-aware worker limits
\item Automatic work-stealing for load balancing
}
}
\details{
\subsection{Worker Allocation Strategy}{

The function implements intelligent worker allocation:

\strong{Grid Search}:
\itemize{
\item Workers = min(requested, n_hyperparameters × cv_folds, available_cores - 2)
\item Each worker evaluates one hyperparameter combination across all CV folds
}

\strong{Bayesian Optimization}:
\itemize{
\item Workers = min(requested, cv_folds, available_cores - 2)
\item Each iteration evaluates one hyperparameter across CV folds in parallel
}

\strong{Refitting}:
\itemize{
\item Workers = min(requested, n_tasks, available_cores - 2)
\item Higher resolution tuning for top models
}
}

\subsection{Nested Parallelization Prevention}{

Uses environment variable \code{HORIZONS_PARALLEL_LEVEL}:
\itemize{
\item Level 0: Top-level orchestrator (can parallelize)
\item Level 1: Worker process (must run sequentially)
\item Level 2+: Nested worker (error condition)
}
}
}
\examples{
\dontrun{
# Setup for grid search
worker_config <- manage_worker_pool(
  n_workers_requested = 50,
  task_type           = "grid_search",
  n_tasks             = 50,  # 10 hyperparams × 5 CV folds
  cv_folds            = 5
)

# Use the configured plan
worker_config$parallel_plan

# Run parallel operations...

# Cleanup when done
worker_config$cleanup_fn()
}

}
\seealso{
\code{\link{run_hpc_evaluation}}, \code{\link{evaluate_model_fit_parallel}}
}
