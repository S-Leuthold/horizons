% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline-configure.R
\name{configure}
\alias{configure}
\title{Pipeline: Configure Model Pipelines}
\usage{
configure(
  x,
  outcome = NULL,
  models = c("rf", "cubist", "plsr"),
  transformations = "none",
  preprocessing = "raw",
  feature_selection = "none",
  expand_covariates = NULL,
  cov_fusion = NULL,
  cv_folds = 5L,
  grid_size = 10L,
  bayesian_iter = 15L
)
}
\arguments{
\item{x}{\link{horizons_data}. Object with response data attached via
\code{add_response()}.}

\item{outcome}{\link{character(1) or NULL}. Which response variable to model.
Auto-selects if exactly one response exists.}

\item{models}{\link{character}. Model algorithms to benchmark. Default
\code{c("rf", "cubist", "plsr")}. See \code{VALID_MODELS} for options.}

\item{transformations}{\link{character}. Response transformations to test.
Default \code{"none"}.}

\item{preprocessing}{\link{character}. Per-config spectral preprocessing methods.
Default \code{"raw"}.}

\item{feature_selection}{\link{character}. Feature selection methods to test.
Default \code{"none"}.}

\item{expand_covariates}{\link{logical(1), character, or NULL}. Covariate
expansion strategy. NULL = all covariates in every config (no expansion).
TRUE = power set of all covariate columns. Character vector = power set
of named covariates only. FALSE = exclude all covariates.}

\item{cov_fusion}{\link{character(1) or NULL}. Covariate fusion strategy:
NULL (no covariates), \code{"early"}, or \code{"late"}.}

\item{cv_folds}{\link{integer}. Number of cross-validation folds. Default 5.
Minimum 2.}

\item{grid_size}{\link{integer}. Hyperparameter grid size (Latin hypercube).
Default 10. Minimum 1.}

\item{bayesian_iter}{\link{integer}. Bayesian optimization iterations.
Default 15. Minimum 0.}
}
\value{
A modified \code{horizons_data} object with:
\itemize{
\item Outcome variable promoted to \code{role = "outcome"} in \code{data$role_map}
\item \code{config$configs} — tibble of configuration grid (9 columns)
\item \code{config$n_configs} — integer count
\item \code{config$tuning} — list of tuning parameters
\item \code{config$expansion} — list of original inputs (for reproducibility)
\item \code{config$defaults} — list of method defaults
}
}
\description{
Defines the experimental design space for model evaluation. Takes a
\code{horizons_data} object with response data attached and specifies which
combinations of models, transformations, preprocessing, and feature selection
to benchmark.
}
\details{
\code{configure()} builds a configuration grid — the Cartesian product of all
specified modeling axes. Each row represents a distinct pipeline to
evaluate. This is the bridge between data preparation (\code{add_response()})
and model evaluation (\code{evaluate()}).

\strong{Outcome promotion:}

\code{add_response()} assigns \code{role = "response"} to joined variables.
\code{configure()} promotes exactly one response to \code{role = "outcome"} for
modeling. If only one response exists, it's auto-selected. Multiple
responses require explicit \code{outcome} specification.

\strong{Covariate expansion:}

When covariates are present, \code{expand_covariates} controls whether to
benchmark across different covariate subsets (power-set expansion) or
use all covariates in every configuration.

\strong{Reconfiguration:}

Can be called multiple times on the same object. Previous configuration
is overwritten, and any prior outcome role is reverted to "response".
This enables the \code{purrr::map()} multi-outcome pattern:

\if{html}{\out{<div class="sourceCode">}}\preformatted{c("SOC", "POM_C", "pH") |>
  purrr::map(~base |> configure(outcome = .x) |> evaluate() |> fit())
}\if{html}{\out{</div>}}
}
\examples{
\dontrun{
# Minimal (single response auto-selected)
hd |> configure()

# Explicit outcome with multiple responses
hd |> configure(outcome = "SOC")

# Full experimental design
hd |> configure(
  outcome         = "SOC",
  models          = c("rf", "cubist", "plsr", "xgboost"),
  transformations = c("none", "log"),
  preprocessing   = c("raw", "snv", "sg"),
  cv_folds        = 10L,
  grid_size       = 20L
)

# Multi-outcome pattern
c("SOC", "POM_C", "pH") |>
  purrr::map(~base |> configure(outcome = .x) |> evaluate() |> fit())
}

}
