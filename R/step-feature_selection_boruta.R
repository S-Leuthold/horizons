#' Boruta-Based Feature Selection for Spectral Predictors
#'
#' Applies the Boruta algorithm to select informative spectral predictors by comparing
#' variable importance scores against randomized shadow features. Intended for use after
#' spectral preprocessing (e.g., SNV + derivatives) and before downstream modeling.
#'
#' @param recipe A `recipes::recipe()` object.
#' @param ... Selector functions to choose spectral columns (e.g., `all_predictors()`).
#' @param outcome Character. Name of the outcome variable to use for model fitting.
#' @param role Character. Role for retained variables. Default is `"predictor"`.
#' @param trained Logical. Required by `recipes`; indicates if the step has been prepped.
#' @param skip Logical. Should this step be skipped during `bake()`? Default is `FALSE`.
#' @param id Character. Unique identifier for the step. Auto-generated by default.
#'
#' @return A `step_select_boruta` object that can be added to a recipe.
#'
#' @details
#' This step uses the Boruta feature selection algorithm, which runs a random forest model
#' comparing each original predictor to shuffled "shadow" variables. Variables consistently
#' more important than the best shadow are retained. The algorithm is run at `prep()` time.
#'
#' For best results, this step should be applied *after* spectral preprocessing (e.g. SNV,
#' derivatives) and *before* PCA or model fitting. It may be computationally expensive
#' for large spectral datasets.
#'
#' @export

## -----------------------------------------------------------------------------
## Step 1: User-facing step constructor
## -----------------------------------------------------------------------------

#' @export
step_select_boruta <- function(recipe,
                               ...,
                               outcome,
                               role    = "predictor",
                               trained = FALSE,
                               skip    = FALSE,
                               id      = recipes::rand_id("select_boruta")) {

  terms <- rlang::enquos(...)

  recipes::add_step(recipe,
                    step_select_boruta_new(columns       = terms,
                                           outcome       = outcome,
                                           role          = role,
                                           trained       = trained,
                                           selected_vars = NULL,
                                           skip          = skip,
                                           id            = id))
}

## -----------------------------------------------------------------------------
## Step 2: Constructor
## -----------------------------------------------------------------------------

#' @export
step_select_boruta_new <- function(columns,
                                   outcome,
                                   role,
                                   trained,
                                   selected_vars,
                                   skip,
                                   id) {

  out <- list(columns        = columns,
              outcome        = outcome,
              role           = role,
              trained        = trained,
              selected_vars  = selected_vars,
              skip           = skip,
              id             = id )

  class(out) <- c("step_select_boruta", "step")
  return(out)

}

## -----------------------------------------------------------------------------
## Step 3: prep() method
## -----------------------------------------------------------------------------

#' @export
prep.step_select_boruta <- function(x, training, info = NULL, ...) {

  ## ---------------------------------------------------------------------------
  ## Stage 1: Resolve spectral column names
  ## ---------------------------------------------------------------------------

  col_names <- recipes::recipes_eval_select(x$columns, training, info)

  if (!is.character(x$outcome) || length(x$outcome) != 1) {
    cli::cli_abort("The {.arg outcome} must be a single character string.")
  }

  if (!x$outcome %in% names(training)) {
    cli::cli_abort("Outcome column {.val {x$outcome}} not found in training data.")
  }

  outcome_vec  <- training[[x$outcome]]
  spectra_mat  <- as.matrix(training[, col_names, drop = FALSE])

  ## ---------------------------------------------------------------------------
  ## Stage 2: Cluster predictors before Boruta
  ## ---------------------------------------------------------------------------

  cluster_spectral_predictors(spectra_mat,
                              k      = 150,
                              method = "correlation") -> cluster_result

  reduced_mat   <- cluster_result$reduced_mat
  cluster_map   <- cluster_result$cluster_map
  cluster_vars  <- cluster_result$selected_vars

  cli::cli_alert_info("Boruta feature selection using {length(cluster_vars)} clustered predictors (from {length(col_names)} original wavenumbers)...")

  ## ---------------------------------------------------------------------------
  ## Stage 3: Run Boruta
  ## ---------------------------------------------------------------------------

  boruta_fit <- Boruta::Boruta(x       = reduced_mat,
                               y       = outcome_vec,
                               doTrace = 0,
                               maxRuns = 40,
                               holdHistory = FALSE)

  kept_cluster_vars <- Boruta::getSelectedAttributes(boruta_fit, withTentative = TRUE)

  ## ---------------------------------------------------------------------------
  ## Stage 4: Map back to original wavenumbers
  ## ---------------------------------------------------------------------------

  kept_wavenumbers <- unique(unlist(cluster_map[kept_cluster_vars]))

  if (length(kept_wavenumbers) == 0) {
    cli::cli_alert_warning("No wavenumbers retained by Boruta. Retaining all original predictors.")
    kept_wavenumbers <- col_names
  }

  ## ---------------------------------------------------------------------------
  ## Stage 5: Return trained step
  ## ---------------------------------------------------------------------------

  step_select_boruta_new(columns        = col_names,
                         outcome        = x$outcome,
                         role           = x$role,
                         trained        = TRUE,
                         selected_vars  = kept_wavenumbers,
                         skip           = x$skip,
                         id             = x$id)
}


## -----------------------------------------------------------------------------
## Step 4: bake() method
## -----------------------------------------------------------------------------

#' @export
bake.step_select_boruta <- function(object, new_data, ...) {

  if (is.null(object$selected_vars)) {
    cli::cli_abort("This step has not been trained yet. Please call `prep()` first.")
  }

  if (!all(object$selected_vars %in% names(new_data))) {
    cli::cli_abort("Some selected wavenumbers are missing in new_data.")
  }

  ## Retain: selected spectral vars + all non-spectral columns
  keep_cols <- c(object$selected_vars,
                 setdiff(names(new_data),
                         object$columns))

  dplyr::select(new_data, dplyr::all_of(keep_cols))

}

## -----------------------------------------------------------------------------
## Step 5: print() method
## -----------------------------------------------------------------------------

#' @export
print.step_select_boruta <- function(x,
                                     width = max(20, options()$width - 30),
                                     ...) {

  cat("Boruta-based spectral feature selection step\n")
  cat(glue::glue("• Outcome column: {x$outcome}\n"))

  if (x$trained) {
    cat(glue::glue("• {length(x$selected_vars)} wavenumbers retained after Boruta\n"))
  } else {
    cat("• Step not yet trained\n")
  }

  invisible(x)
}


