#' Boruta-Based Feature Selection for Spectral Predictors
#'
#' Applies the Boruta algorithm to select informative spectral predictors by comparing
#' variable importance scores against randomized shadow features. Intended for use after
#' spectral preprocessing (e.g., SNV + derivatives) and before downstream modeling.
#'
#' @param recipe A `recipes::recipe()` object.
#' @param ... Selector functions to choose spectral columns (e.g., `all_predictors()`).
#' @param outcome Character. Name of the outcome variable to use for model fitting.
#' @param role Character. Role for retained variables. Default is `"predictor"`.
#' @param trained Logical. Required by `recipes`; indicates if the step has been prepped.
#' @param skip Logical. Should this step be skipped during `bake()`? Default is `FALSE`.
#' @param id Character. Unique identifier for the step. Auto-generated by default.
#'
#' @return A `step_select_boruta` object that can be added to a recipe.
#'
#' @details
#' This step uses the Boruta feature selection algorithm, which runs a random forest model
#' comparing each original predictor to shuffled "shadow" variables. Variables consistently
#' more important than the best shadow are retained. The algorithm is run at `prep()` time.
#'
#' For best results, this step should be applied *after* spectral preprocessing (e.g. SNV,
#' derivatives) and *before* PCA or model fitting. It may be computationally expensive
#' for large spectral datasets.
#'
#' @export

## -----------------------------------------------------------------------------
## Step 1: User-facing step constructor
## -----------------------------------------------------------------------------

#' @export
step_select_boruta <- function(recipe,
                               ...,
                               outcome,
                               role    = "predictor",
                               trained = FALSE,
                               skip    = FALSE,
                               id      = recipes::rand_id("select_boruta")) {

  terms <- rlang::enquos(...)

  recipes::add_step(recipe,
                    step_select_boruta_new(columns       = terms,
                                           outcome       = outcome,
                                           role          = role,
                                           trained       = trained,
                                           selected_vars = NULL,
                                           skip          = skip,
                                           id            = id))
}

## -----------------------------------------------------------------------------
## Step 2: Constructor
## -----------------------------------------------------------------------------

#' @export
step_select_boruta_new <- function(columns,
                                   outcome,
                                   role,
                                   trained,
                                   selected_vars,
                                   skip,
                                   id) {

  out <- list(columns        = columns,
              outcome        = outcome,
              role           = role,
              trained        = trained,
              selected_vars  = selected_vars,
              skip           = skip,
              id             = id )

  class(out) <- c("step_select_boruta", "step")
  return(out)

}

## -----------------------------------------------------------------------------
## Step 3: prep() method
## -----------------------------------------------------------------------------

#' @export
prep.step_select_boruta <- function(x, training, info = NULL, ...) {

  ## ---------------------------------------------------------------------------
  ## Stage 1: Resolve spectral column names
  ## ---------------------------------------------------------------------------

  col_names <- recipes::recipes_eval_select(x$columns, training, info)

  if (!is.character(x$outcome) || length(x$outcome) != 1) {
    cli::cli_abort("The {.arg outcome} must be a single character string.")
  }

  if (!x$outcome %in% names(training)) {
    cli::cli_abort("Outcome column {.val {x$outcome}} not found in training data.")
  }

  outcome_vec  <- training[[x$outcome]]
  spectra_mat  <- as.matrix(training[, col_names, drop = FALSE])

  ## ---------------------------------------------------------------------------
  ## Stage 2: Variance filtering and clustering
  ## ---------------------------------------------------------------------------

  # Remove near-constant features before clustering
  variance_check <- apply(spectra_mat, 2, var, na.rm = TRUE)
  keep_cols <- variance_check > 1e-10
  
  if(sum(keep_cols) < ncol(spectra_mat)) {
    cli::cli_alert_info("Filtering {ncol(spectra_mat) - sum(keep_cols)} near-constant features before clustering")
    spectra_mat <- spectra_mat[, keep_cols, drop = FALSE]
    col_names_filtered <- col_names[keep_cols]
  } else {
    col_names_filtered <- col_names
  }

  # Use more aggressive clustering for spectral data (k=50 instead of 150)
  cluster_spectral_predictors(spectra_mat,
                              k      = min(50, ncol(spectra_mat)),
                              method = "correlation") -> cluster_result

  reduced_mat   <- cluster_result$reduced_mat
  cluster_map   <- cluster_result$cluster_map
  cluster_vars  <- cluster_result$selected_vars

  ## ---------------------------------------------------------------------------
  ## Stage 3: Run Boruta with optimized parameters
  ## ---------------------------------------------------------------------------

  # Optimize Random Forest parameters for correlated features
  n_features <- ncol(reduced_mat)
  optimal_mtry <- min(max(5, round(sqrt(n_features) * 2)), n_features - 1)

  ## Create custom ranger function with thread control for Boruta ----
  
  ranger_single_thread <- function(...) {
    ranger::ranger(..., num.threads = 1)
  }
  
  boruta_fit <- tryCatch({
    ## Run Boruta with thread-controlled ranger ----
    
    Boruta::Boruta(x       = reduced_mat,
                   y       = outcome_vec,
                   doTrace = 0,
                   maxRuns = 50,         # Reduced for faster execution
                   ntree   = 500,        # Reduced for faster execution  
                   mtry    = optimal_mtry, # Optimized for correlated predictors
                   holdHistory = FALSE,
                   getImp = function(x, y, ...) {
                     ## Custom importance function with explicit thread control ----
                     
                     rf <- ranger::ranger(
                       x = x,
                       y = y,
                       num.trees = 500,
                       mtry = optimal_mtry,
                       importance = "impurity",
                       num.threads = 1,  # Force single thread
                       verbose = FALSE
                     )
                     return(rf$variable.importance)
                   })
  }, error = function(e) {
    cli::cli_alert_warning("Boruta failed: {e$message}")
    cli::cli_alert_info("Falling back to correlation-based selection")
    NULL
  })

  # Handle Boruta results or fallback
  if(!is.null(boruta_fit)) {
    kept_cluster_vars <- Boruta::getSelectedAttributes(boruta_fit, withTentative = TRUE)
  } else {
    # Fallback: select top 50 most correlated features
    cors <- abs(cor(reduced_mat, outcome_vec, use = "pairwise.complete.obs"))
    top_cors <- sort(cors[,1], decreasing = TRUE)[1:min(50, length(cors[,1]))]
    kept_cluster_vars <- names(top_cors)
    cli::cli_alert_info("Selected {length(kept_cluster_vars)} features via correlation fallback")
  }

  ## ---------------------------------------------------------------------------
  ## Stage 4: Map back to original wavenumbers
  ## ---------------------------------------------------------------------------

  kept_wavenumbers <- unique(unlist(cluster_map[kept_cluster_vars]))

  if (length(kept_wavenumbers) == 0) {
    cli::cli_alert_warning("No wavenumbers retained by Boruta. Retaining all variance-filtered predictors.")
    kept_wavenumbers <- col_names_filtered
  }

  ## ---------------------------------------------------------------------------
  ## Stage 5: Return trained step
  ## ---------------------------------------------------------------------------

  step_select_boruta_new(columns        = col_names,
                         outcome        = x$outcome,
                         role           = x$role,
                         trained        = TRUE,
                         selected_vars  = kept_wavenumbers,
                         skip           = x$skip,
                         id             = x$id)
}


## -----------------------------------------------------------------------------
## Step 4: bake() method
## -----------------------------------------------------------------------------

#' @export
bake.step_select_boruta <- function(object, new_data, ...) {

  if (is.null(object$selected_vars)) {
    cli::cli_abort("This step has not been trained yet. Please call `prep()` first.")
  }

  if (!all(object$selected_vars %in% names(new_data))) {
    cli::cli_abort("Some selected wavenumbers are missing in new_data.")
  }

  ## Retain: selected spectral vars + all non-spectral columns
  keep_cols <- c(object$selected_vars,
                 setdiff(names(new_data),
                         object$columns))

  dplyr::select(new_data, dplyr::all_of(keep_cols))

}

## -----------------------------------------------------------------------------
## Step 5: print() method
## -----------------------------------------------------------------------------

#' @export
print.step_select_boruta <- function(x,
                                     width = max(20, options()$width - 30),
                                     ...) {

  cat("Boruta-based spectral feature selection step\n")
  cat(glue::glue("• Outcome column: {x$outcome}\n"))

  if (x$trained) {
    cat(glue::glue("• {length(x$selected_vars)} wavenumbers retained after Boruta\n"))
  } else {
    cat("• Step not yet trained\n")
  }

  invisible(x)
}


