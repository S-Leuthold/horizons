#' Correlation-Based Feature Selection for Spectral Predictors
#'
#' Applies sliding-window Spearman correlation to identify predictive spectral regions.
#' Retains all wavenumbers that appear in windows where the mean absolute Spearman
#' correlation with the outcome exceeds an adaptive threshold (mean + 1 standard deviation).
#' Designed for use with high-resolution MIR spectra in wide format (columns = wavenumbers).
#'
#' @param recipe A `recipes::recipe()` object.
#' @param ... Selector functions to choose spectral predictor columns (e.g., `all_predictors()`).
#' @param outcome Character. Name of the outcome variable to use for correlation scoring.
#' @param role Character. Role for retained variables. Default is `"predictor"`.
#' @param trained Logical. Required by `recipes`; indicates if the step has been prepped.
#' @param skip Logical. Should this step be skipped during `bake()`? Default is `FALSE`.
#' @param id Character. Unique identifier for the step. Auto-generated by default.
#'
#' @return A `step_select_correlation` object that can be added to a recipe.
#'
#' @details
#' The selection algorithm slides a 3-wavenumber window (6 cm⁻¹ at 2 cm⁻¹ resolution) across
#' the spectrum, computes the mean absolute Spearman correlation between each window and
#' the outcome, and retains all wavenumbers from windows where the score exceeds
#' `mean + 1 SD`. Duplicate selections are collapsed. If no windows meet the threshold,
#' all input wavenumbers are retained with a warning.
#'
#' This step is designed to operate on spectra that have already been preprocessed
#' (e.g., SNV + derivative). It should be applied after spectral transformation but
#' before dimensionality reduction (e.g., PCA) or model fitting.
#'
#' @seealso [recipes::recipe()], [recipes::prep()], [recipes::bake()]
#'
#' @importFrom recipes recipe prep bake step add_step rand_id recipes_eval_select update_role update_role_requirements all_predictors all_outcomes
#' @importFrom dplyr select all_of
#' @importFrom purrr map_dbl map
#' @importFrom cli cli_abort cli_alert_info cli_alert_warning
#' @importFrom glue glue
#' @importFrom stats cor sd
#' @importFrom zoo rollmean
#' @importFrom rlang enquos
#'
#' @export



## -----------------------------------------------------------------------------
## Step 1: User-facing step constructor
## -----------------------------------------------------------------------------

#' @export
step_select_correlation <- function(recipe,
                                    ...,
                                    outcome,
                                    role        = "predictor",
                                    trained     = FALSE,
                                    skip        = FALSE,
                                    id          = recipes::rand_id("select_correlation")) {

  terms <- rlang::enquos(...)

  recipes::add_step(
    recipe,
    step_select_correlation_new(
      columns       = terms,
      outcome       = outcome,
      role          = role,
      trained       = trained,
      selected_vars = NULL,
      skip          = skip,
      id            = id
    )
  )
}

## -----------------------------------------------------------------------------
## Step 2: Constructor
## -----------------------------------------------------------------------------

#' @export
step_select_correlation_new <- function(columns,
                                        outcome,
                                        role,
                                        trained,
                                        selected_vars = NULL,
                                        skip,
                                        id) {
  out <- list(
    columns          = columns,
    outcome          = outcome,
    role             = role,
    trained          = trained,
    selected_vars    = selected_vars,
    skip             = skip,
    id               = id)

  class(out) <- c("step_select_correlation", "step")
  return(out)

  }

## -----------------------------------------------------------------------------
## Step 3: prep() method
## -----------------------------------------------------------------------------

#' @export
prep.step_select_correlation <- function(x, training, info = NULL, ...) {

  ## Stage 1: Evaluate column predictors (No changes)
  col_names <- recipes::recipes_eval_select(x$columns, training, info)
  if (!is.character(x$outcome) || length(x$outcome) != 1) {
    cli::cli_abort("The {.arg outcome} must be a single character string.")
  }
  if (!x$outcome %in% names(training)) {
    cli::cli_abort("Outcome column {.val {x$outcome}} not found in training data.")
  }
  outcome_vec <- training[[x$outcome]]
  spectra_mat <- as.matrix(training[, col_names])

  ## ---------------------------------------------------------------------------
  ## Stage 2: Vectorized correlation and rolling mean
  ## ---------------------------------------------------------------------------

  cli::cli_alert_info("Calculating vectorized correlations...")

  # 1. Calculate all correlations in one fast operation
  all_cor_scores <- stats::cor(spectra_mat, outcome_vec, method = "spearman")

  # 2. Use a highly efficient rolling mean function
  window_size   <- 3
  window_scores <- zoo::rollmean(x = abs(as.vector(all_cor_scores)), k = window_size)

  threshold <- mean(window_scores, na.rm = TRUE) + stats::sd(window_scores, na.rm = TRUE)
  keep_indices <- which(window_scores >= threshold)

  if (length(keep_indices) == 0) {
    cli::cli_alert_warning("No windows met the threshold. Retaining all predictors.")
    kept_wavenumbers <- col_names
  } else {
    ## Stage 4: Extract the wavenumbers that should be retained
    kept_wavenumbers <- unique(
      unlist(
        purrr::map(keep_indices, ~ col_names[.x:(.x + window_size - 1)])
      )
    )
  }

  step_select_correlation_new(
    columns       = col_names,
    outcome       = x$outcome,
    role          = x$role,
    trained       = TRUE,
    selected_vars = kept_wavenumbers,
    skip          = x$skip,
    id            = x$id
  )
}

## -----------------------------------------------------------------------------
## Step 4: bake() method
## -----------------------------------------------------------------------------

#' @export
bake.step_select_correlation <- function(object, new_data, ...) {

  if (is.null(object$selected_vars)) {
    cli::cli_abort("This step has not been trained yet. Please call `prep()` first.")
  }

  original_predictors <- object$columns
  other_cols          <- setdiff(names(new_data), original_predictors)
  keep_cols           <- c(object$selected_vars, other_cols)
  final_cols          <- intersect(keep_cols, names(new_data))

  new_data[, final_cols, drop = FALSE]

}

## -----------------------------------------------------------------------------
## Step 5: print() method
## -----------------------------------------------------------------------------

#' @export

print.step_select_correlation <- function(x,
                                          width = max(20, options()$width - 30),
                                          ...) {

  cat("Correlation-based spectral feature selection step\n")
  cat(glue::glue("• Outcome column: {x$outcome}\n"))

  if (x$trained) {
    cat(glue::glue("• {length(x$selected_vars)} wavenumbers retained after windowed scoring\n"))
  } else {
    cat("• Step not yet trained\n")
  }

  invisible(x)
}

