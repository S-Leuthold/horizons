#' Correlation-Based Feature Selection for Spectral Predictors
#'
#' Applies sliding-window Spearman correlation to identify predictive spectral regions.
#' Retains all wavenumbers that appear in windows where the mean absolute Spearman
#' correlation with the outcome exceeds an adaptive threshold (mean + 1 standard deviation).
#' Designed for use with high-resolution MIR spectra in wide format (columns = wavenumbers).
#'
#' @param recipe A `recipes::recipe()` object.
#' @param ... Selector functions to choose spectral predictor columns (e.g., `all_predictors()`).
#' @param outcome Character. Name of the outcome variable to use for correlation scoring.
#' @param role Character. Role for retained variables. Default is `"predictor"`.
#' @param trained Logical. Required by `recipes`; indicates if the step has been prepped.
#' @param skip Logical. Should this step be skipped during `bake()`? Default is `FALSE`.
#' @param id Character. Unique identifier for the step. Auto-generated by default.
#'
#' @return A `step_select_correlation` object that can be added to a recipe.
#'
#' @details
#' The selection algorithm slides a 3-wavenumber window (6 cm⁻¹ at 2 cm⁻¹ resolution) across
#' the spectrum, computes the mean absolute Spearman correlation between each window and
#' the outcome, and retains all wavenumbers from windows where the score exceeds
#' `mean + 1 SD`. Duplicate selections are collapsed. If no windows meet the threshold,
#' all input wavenumbers are retained with a warning.
#'
#' This step is designed to operate on spectra that have already been preprocessed
#' (e.g., SNV + derivative). It should be applied after spectral transformation but
#' before dimensionality reduction (e.g., PCA) or model fitting.
#'
#' @seealso [recipes::recipe()], [recipes::prep()], [recipes::bake()]
#'
#' @importFrom recipes recipe prep bake step add_step rand_id recipes_eval_select update_role update_role_requirements all_predictors all_outcomes
#' @importFrom dplyr select all_of
#' @importFrom purrr map_dbl map
#' @importFrom cli cli_abort cli_alert_info cli_alert_warning
#' @importFrom glue glue
#' @importFrom stats cor sd
#' @importFrom rlang enquos

#'
#' @export



## -----------------------------------------------------------------------------
## Step 1: User-facing step constructor
## -----------------------------------------------------------------------------

#' @export
step_select_correlation <- function(recipe,
                                    ...,
                                    outcome,
                                    role        = "predictor",
                                    trained     = FALSE,
                                    skip        = FALSE,
                                    id          = recipes::rand_id("select_correlation")) {

  terms <- rlang::enquos(...)

  recipes::add_step(
    recipe,
    step_select_correlation_new(
      columns       = terms,
      outcome       = outcome,
      role          = role,
      trained       = trained,
      selected_vars = NULL,
      skip          = skip,
      id            = id
    )
  )
}

## -----------------------------------------------------------------------------
## Step 2: Constructor
## -----------------------------------------------------------------------------

#' @export
step_select_correlation_new <- function(columns,
                                        outcome,
                                        role,
                                        trained,
                                        selected_vars = NULL,
                                        skip,
                                        id) {
  out <- list(
    columns          = columns,
    outcome          = outcome,
    role             = role,
    trained          = trained,
    selected_vars    = selected_vars,
    skip             = skip,
    id               = id)

  class(out) <- c("step_select_correlation", "step")
  return(out)

  }

## -----------------------------------------------------------------------------
## Step 3: prep() method
## -----------------------------------------------------------------------------

#' @export
prep.step_select_correlation <- function(x, training, info = NULL, ...) {

  ## ---------------------------------------------------------------------------
  ## Stage 1: Evaluate column predictors
  ## ---------------------------------------------------------------------------

  col_names <- recipes::recipes_eval_select(x$columns, training, info)

  if (!is.character(x$outcome) || length(x$outcome) != 1) {
    cli::cli_abort("The {.arg outcome} must be a single character string.")
  }
  if (!x$outcome %in% names(training)) {
    cli::cli_abort("Outcome column {.val {x$outcome}} not found in training data.")
  }

  outcome_vec <- training[[x$outcome]]
  spectra_mat <- as.matrix(training[, col_names])

  ## ---------------------------------------------------------------------------
  ## Stage 2: Compute absolute Spearman correlation for sliding window
  ## ---------------------------------------------------------------------------

  window_size <- 3
  n_windows   <-  ncol(spectra_mat) - window_size + 1

  purrr::map_dbl(.x = seq_len(n_windows),
                 .f = function(i) {

                   window_cols <- spectra_mat[, i:(i + window_size - 1), drop = FALSE]

                   tryCatch({

                     mean(abs(apply(X      = window_cols,
                                    MARGIN = 2,
                                    FUN    = function(col) cor(col, outcome_vec, method = "spearman"))), na.rm = TRUE)

                     }, error = function(e) {

                       NA_real_
                    })  ->  avg_correlation

                   return(avg_correlation)

                  }) -> window_scores

  ## ---------------------------------------------------------------------------
  ## Stage 3: Apply the dynamic threshold (mean + 1 sd)
  ## ---------------------------------------------------------------------------

  keep_cols <- which(window_scores >= (mean(window_scores, na.rm = TRUE) + stats::sd(window_scores, na.rm = TRUE)))

  ## ---------------------------------------------------------------------------
  ## Stage 4: Extract the wavenumbers that should be reatined.
  ## ---------------------------------------------------------------------------

  unique(
    unlist(
      purrr::map(.x = keep_cols,
                 .f = ~ col_names[.x:(.x+window_size - 1)]
                 )
      )
    ) -> kept_wavenumbers

  if (length(kept_wavenumbers) > 0.75 * length(col_names)) {
    cli::cli_alert_info("High selection density: {length(kept_wavenumbers)} of {length(col_names)} wavenumbers retained. Consider revisiting thresholds.")
  }

  if (length(kept_wavenumbers) == 0) {
    cli::cli_alert_warning("No wavenumbers selected. Consider adjusting the threshold or window size.")
    kept_wavenumbers <- col_names
  }

  ## ---------------------------------------------------------------------------
  ## Stage 5: Return the trained object
  ## ---------------------------------------------------------------------------

  step_select_correlation_new(columns       = x$columns,
                              outcome       = x$outcome,
                              role          = x$role,
                              trained       = TRUE,
                              selected_vars = kept_wavenumbers,
                              skip          = x$skip,
                              id            = x$id)

}

## -----------------------------------------------------------------------------
## Step 4: bake() method
## -----------------------------------------------------------------------------

#' @export
bake.step_select_correlation <- function(object, new_data, ...) {

  if (is.null(object$selected_vars)) {
    cli::cli_abort("This step has not been trained yet. Please call `prep()` first.")
  }

  if (!all(object$selected_vars %in% names(new_data))) {
    cli::cli_abort("Some selected wavenumbers are missing in new_data.")
  }

  keep_cols <- c(object$selected_vars,
                 setdiff(names(new_data), object$columns))

  dplyr::select(new_data, dplyr::all_of(keep_cols))

}

## -----------------------------------------------------------------------------
## Step 5: print() method
## -----------------------------------------------------------------------------

#' @export

print.step_select_correlation <- function(x,
                                          width = max(20, options()$width - 30),
                                          ...) {

  cat("Correlation-based spectral feature selection step\n")
  cat(glue::glue("• Outcome column: {x$outcome}\n"))

  if (x$trained) {
    cat(glue::glue("• {length(x$selected_vars)} wavenumbers retained after windowed scoring\n"))
  } else {
    cat("• Step not yet trained\n")
  }

  invisible(x)
}

